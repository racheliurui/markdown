<!-- TOC START min:1 max:3 link:true update:true -->
- [What is Kerbose and how it is designed](#what-is-kerbose-and-how-it-is-designed)
  - [Designing an Authentication System: a Dialogue in Four Scenes](#designing-an-authentication-system-a-dialogue-in-four-scenes)
- [my own understanding](#my-own-understanding)
  - [Scene 1](#scene-1)
  - [Scene 2](#scene-2)
  - [Scene 3,](#scene-3)
  - [Scene 4](#scene-4)

<!-- TOC END -->

# What is Kerbose and how it is designed

## Designing an Authentication System: a Dialogue in Four Scenes

https://web.mit.edu/kerberos/dialogue.html

http://www.xuebuyuan.com/748249.html

# my own understanding

## Scene 1

## Scene 2

1. step 客户端向认证服务器Charon请求， 并提交用户名密码和请求的服务名
2. step 认证服务器Charon检查用户名密码，如果全部正确，则返回一个使用认证服务器的公钥加密的票根， 包含用户名
3. step 客户端使用票根请求服务，服务器使用私钥解密票根，获取用户名，通过则向该用户提供服务

__漏洞__： 服务器无法知道解密的票根结果是否正确

__改进__： 票根包含： { 用户名， 服务名 }；由于服务名类似约定内容，这样服务器解密后从内容中得到正确服务名，验证解密正确

__漏洞__： 如果票根包被拦截，其它客户端可以使用拦截的票根发起请求

__改进__：票根包含初始请求客户端ip地址 ，票根包含： { 用户名，请求IP， 服务名 }这样拦截票根的客户端发起请求也无法通过验证（ip对不上）

__新需求__： 每次服务请求都需要反复请求票根太麻烦，即使相同服务可以重用票根，可是不同的服务还是需要重新申请票根，而且不安全 （多次明文提交密码给Charon服务器），可能被人猜出来。

## Scene 3,

__试图解决的问题__：

* 第一个限制：用户只输一次口令，在他们工作站启动的时候，这意味着当你需要申请新的服务的票时，不需输入你的口令。
* 第二个限制：口令不能在网络上进行明文传输。

__步骤__

1. step 客户端通过kinit来跟认证服务器Charon请求服务。当客户端输入用户名和密码后，kinit只把用户名和请求发给认证服务器Charon
2. step 认证服务器Charon将一组票根使用用户的密码进行加密后返回给kinit
3. step kinit使用step1中客户输入的密码对认证服务器Charon返回的票根进行解密。成功解密后就可以使用相应票根请求相应服务了。

解决了上述两根问题。（只输入一次口令，而且口令不需要在网络上明文传输）

__漏洞__： 大量票根存放在本地不安全。 黑客只需要窃取票根，并且模拟用户ip地址就可以访问所有用户的服务。

__改进__：在票根中加入时间戳， 约定过期时间（例如八小时）。记住，票根中的信息是用服务提供者的公钥加密过的。这样服务提供者解密票根后可以知道是谁在什么时间请求了这些服务， 是否过期。

__漏洞__：但是，在时间戳过期前，仍旧是不安全的。

## Scene 4

__试图解决的问题__：

试图解决的问题：Scene3中的遗留问题。即在时间戳过期前，票根被截取，ip地址被模拟。

__步骤__

1. step 客户端通过kinit来跟认证服务器Charon请求服务。当客户端输入用户名和密码后，kinit只把用户名和请求发给认证服务器Charon
2. step 认证服务器Charon将一组票根和一个动态口令使用用户的密码进行加密后返回给kinit
Charon的回应－客户端口令加密的（[口令｜票]） ；其中 票= 服务公钥加密的｛口令：用户名：地址：服务名：有效期：时间戳｝
3. step kinit使用step1中客户输入的密码对认证服务器Charon返回的返回进行解密, 成功解密后，除了票根，还得到了一个动态口令，这个动态口令跟服务公钥加密中包含的口令相同。
4. step 请求服务时，使用动态口令对｛用户名：地址｝进行加密，然后跟票根一起提交服务请求。
5. step 服务使用服务私钥解密票根，得到动态口令，使用动态口令解密跟票根一起提交的用户名和地址，如果对得上，则通过。

__漏洞__： 拷贝包含动态口令加密过的票根和模拟ip地址（但是不知道动态口令），仍旧可以在时间戳过期前复用票根。
改进：给动态口令加密的内容中加上时间戳，比如两分钟，然后每次用动态口令加密的时候里面加密进去一个时间戳，然后服务端用动态口令解密后检查时间戳是否失效，这样即使截获到包含正确动态口令加密过的数据包仍然是没有足够的时间重演的（需要模拟ip地址重发）。


__如果动态密码本身被截获就不同了。如何解决？__

但是其实是不可能的，因为动态口令在回给kinit的时候使用客户的key进行了加密，所以只有正确的kinit客户端才有用户的密码解开包，看到动态口令。截获包含动态密码的数据包也是没有用的

__漏洞__： 这个场景保护的是服务不被假冒的客户使用。但是并不保证客户访问的是真正的服务器，如果在routing上做手脚，用户可能把要打印的内容发送给假的服务方。如何解决？


__方案__:

使用上述口令可以解决。
当客户端准备发送敏感数据前，可以要求服务端返回使用动态口令加密的相应。由于动态口令只有客户端和正确的服务端知道，所以只有正确的服务端能够使用动态口令对内容进行加密并发送正确的相应给客户端。
问题解决。


__这样的一种安全方案就叫做Kerberos__
